#
# THIS IS THE BEGINNING OF THE RENDERING CORE FOR BLENDER
#

for i in range(int((melBins/2)-melBins),int(melBins/2)):
    
    # let the user know which object is being worked on
    #
    print("")
    print("Object being animated: " + str(i+1+int(melBins/2)))

    # setup the object mesh and material and insert into scene
    #
    me = bpy.data.meshes.new(objectName+'Mesh'+str(i+int(melBins/2)))
    ob = bpy.data.objects.new(objectName + str(i+int(melBins/2)), me)

    mat = bpy.data.materials.new("CustomColor" + str(i+int(melBins/2)))
    mat.diffuse_color = (1,1,1)
    ob.active_material = mat

    scn.objects.link(ob)
    scn.objects.active = ob

    ob.show_name = False
    ob.rotation_mode = 'QUATERNION'

    me.from_pydata(verts, [], faces)
    me.update()
    
    # script the animation for each object
    #
    for frameNumber in range (1,maxFrames):

        # basic setup and housekeeping for frame animation
        #
        frameMelDataPerBin = (MelData[frameNumber])[(i+int(melBins/2))]

        # set the object scaling and write a keyframe (SCALING PIPES)
        #
        scaleX = 1

        scaleY = float(volumeData[frameNumber])/8

        scaleZ = frameMelDataPerBin
        scaleZ = ((float(scaleZ))/20) + 0.1
        scaleZ = scaleZ*scaleZ

        ob.scale = (scaleX, scaleY, scaleZ)
        ob.keyframe_insert(data_path="scale", index=-1, frame=frameNumber)

        # set the object color and write a keyframe (COLOR PIPES)
        #
        colRed =   ( sin( pi*(i/(melBins/2))                      ) +1) /2
        colGreen = ( cos(-pi*(i/(melBins/2))                      ) +1) /2
        colBlue =  ( sin( (frameNumber/55) + (pi*(i/(melBins/2))) ) +1) /2

        mat.diffuse_color = (colRed,colGreen,colBlue)
        mat.keyframe_insert(data_path="diffuse_color", frame=frameNumber, index=-1)

        # set the object location and write a keyframe (LOCATION PIPES)
        #
        #locX = 2*i
        #locY = sin((frameNumber/10)+(pi*(i/(melBins/2))))
        locX = 5 * cos(i/2 * float(volumeData[frameNumber])/50)
        locY = 5 * sin(i/2 * float(volumeData[frameNumber])/50)
        locZ = 0

        ob.location = (locX,locY,locZ)
        #delta_location
        ob.keyframe_insert(data_path="location", index = -1, frame=frameNumber)

        # set the object rotation and write a keyframe (ROTATION PIPES)
        #
        angleX = 0
        angleY = 0
        angleZ = frameNumber/3
        #angleZ = frameNumber/3 * float(volumeData[frameNumber])/100
        #angleZ = locX*locY*5

        angleX = (((angleX%360)-180)/180)*(pi)
        angleY = (((angleY%360)-180)/180)*(pi)
        angleZ = (((angleZ%360)-180)/180)*(pi)
        #angleZ = (((angleZ%360)-180)/180)*(float(volumeData[frameNumber])/100)
        axisX = [1,0,0]
        axisY = [0,1,0]
        axisZ = [0,0,1]

        objectRotation = Quaternion(axisX,angleX) * Quaternion(axisY,angleY) * Quaternion(axisZ,angleZ)
        
        objectRotation.normalize()
        
        ob.rotation_quaternion = objectRotation
        ob.keyframe_insert(data_path="rotation_quaternion", index = -1, frame=frameNumber)

        # print out some information about the rendering process
        #
        if(frameNumber%1000==0):
            print("Frame " + str(frameNumber) + " finished...")
    
    # print out some information about the rendering process and forget about the finished object
    #
    print("Object " + str(i+1+int(melBins/2)) + " finished, with " + str(maxFrames) + " frames keyed.")
    ob.select = False

#
# THIS IS THE END OF THE RENDERING CORE FOR BLENDER
#

#
#	THE PORTION BELOW CLEANS UP THE BLEND FILE AFTER ANIMATION
#	DO NOT EDIT ANYTHING BELOW THIS LEVEL WHEN DEVELOPING CORES
#
time.sleep(1)
sout("")
sout("")
sout("    ***** ANIMATION FINISHED *****     ")
sout("")
sout("")
time.sleep(3)
bpy.ops.wm.save_as_mainfile(filepath=".\\pyBlender\\Output\\Final.blend")
sout("")
sout("")
sout("    ***** FILE CREATION FINISHED *****     ")
sout("")
sout("")
time.sleep(1)
sout("")
sout("")
sout("    ***** FILES READY FOR DOWNLOAD *****     ")
sout("")
sout("")
time.sleep(1)